<!DOCTYPE html>
<html lang="en" class="light">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Oscillation Simulation (Version 1) - Turbo Pascal Programs</title>
<meta name="description" content="Oscillation Simulation Version 1 - Turbo Pascal program by Kirill Arkhipenko (kusaku, retrewert, aks1983).">
<meta name="keywords" content="Kirill Arkhipenko, Кирилл Архипенко, kusaku, retrewert, aks1983, legacy, Turbo Pascal">
<meta name="author" content="Kirill Arkhipenko">
<link rel="canonical" href="https://kusaku.su/legacy/turbopascal/gas/oscillation-simulation-version-1.html">
<link rel="alternate" hreflang="en" href="https://kusaku.su/legacy/turbopascal/gas/oscillation-simulation-version-1.html">
<link rel="alternate" hreflang="ru" href="https://kusaku.su/legacy/turbopascal/gas/oscillation-simulation-version-1.html">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Oscillation Simulation (Version 1) - Turbo Pascal - Kirill Arkhipenko">
<meta property="og:description" content="Turbo Pascal program by Kirill Arkhipenko (kusaku, retrewert, aks1983).">
<meta property="og:url" content="https://kusaku.su/legacy/turbopascal/gas/oscillation-simulation-version-1.html">
<meta property="og:type" content="website">
<meta property="og:site_name" content="kusaku.su">
<meta property="og:image" content="https://kusaku.su/avatar.webp">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Oscillation Simulation (Version 1) - Turbo Pascal - Kirill Arkhipenko">
<meta name="twitter:description" content="Turbo Pascal program by Kirill Arkhipenko. kusaku, retrewert, aks1983.">
<meta name="twitter:image" content="https://kusaku.su/avatar.webp">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<style>
        html.light body { background: #ffffff; color: #24292f; }
        html.dark body { background: #0d1117; color: #c9d1d9; }
        html.light .bg-white { background-color: #ffffff; }
        html.dark .bg-white { background-color: #161b22; }
        html.light .text-gray-600 { color: #57606a; }
        html.dark .text-gray-600 { color: #8b949e; }
        html.light .text-gray-700 { color: #24292f; }
        html.dark .text-gray-700 { color: #c9d1d9; }
        html.light .text-gray-900 { color: #24292f; }
        html.dark .text-gray-900 { color: #c9d1d9; }
        html.light .border-gray-200 { border-color: #d0d7de; }
        html.dark .border-gray-200 { border-color: #30363d; }
        html.light .hover\:bg-gray-50:hover { background-color: #f6f8fa; }
        html.dark .hover\:bg-gray-50:hover { background-color: #21262d; }

        /* Link hover effects */
        html.light a:hover { color: #0969da; }
        html.dark a:hover { color: #1f6feb; }
        html.dark pre { background: #161b22 !important; }
        html.dark pre code { color: #c9d1d9; background: transparent !important; }
        html.dark .hljs { background: #161b22 !important; color: #c9d1d9; }
        html.dark .hljs-keyword { color: #ff7b72; }
        html.dark .hljs-string { color: #a5d6ff; }
        html.dark .hljs-number { color: #79c0ff; }
        html.dark .hljs-comment { color: #8b949e; }
        html.dark .hljs-function { color: #d2a8ff; }
        html.dark .hljs-variable { color: #ffa657; }
    </style>
<script>
        const getSystemPreference = () => window.matchMedia('(prefers-color-scheme: dark)').matches;
        const applyTheme = () => {
            const theme = localStorage.theme ?? 'system';
            const isDark = theme === 'system' ? getSystemPreference() : theme === 'dark';
            document.documentElement.classList.toggle('light', !isDark);
            document.documentElement.classList.toggle('dark', isDark);
        };
        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', applyTheme) : applyTheme();
        hljs.highlightAll();
    </script>    <script>
        // Register Pascal language for highlight.js
        hljs.registerLanguage('pascal', function(hljs) {
            return {
                keywords: {
                    keyword: 'and array begin case const div do downto else end file for function goto if in label mod nil not of or packed procedure program record repeat set then to type until var while with',
                    built_in: 'boolean char integer real text string',
                    literal: 'true false'
                },
                contains: [
                    hljs.C_LINE_COMMENT_MODE,
                    hljs.C_BLOCK_COMMENT_MODE,
                    hljs.APOS_STRING_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.C_NUMBER_MODE
                ]
            };
        });
    </script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-J8N1Q1GVVB"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-J8N1Q1GVVB');
</script>
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105986243', 'ym');
    ym(105986243, 'init', {ssr:true, webvisor:true, clickmap:true, accurateTrackBounce:true, trackLinks:true});
</script>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto">
        <nav class="mb-6">
            <a href="/legacy/turbopascal/turbopascal.html" class="inline-flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Back to Turbo Pascal Projects
            </a>
        </nav>
        <h1 class="text-3xl font-bold text-gray-900 mb-4">Oscillation Simulation (Version 1)</h1>
        <p class="text-gray-600 mb-6">Version 1 of the oscillation simulation program.</p>
        <div class="bg-white border border-gray-200 rounded-xl p-6 mb-6">
            <h2 class="font-semibold text-gray-900 mb-4">Source Code:</h2>
            <pre><code class="language-pascal">﻿ {$N+}
program Oscill;

uses
  Crt, Graph;

const
   Memory=100;
   Windows=4;

type
  ResolutionPreference=(Lower,Higher);
  ColorList=array [1..Windows] of integer;

var
  Xmax,Ymax,ViewXmax,ViewYmax: integer;
  Color: ColorList;
  Ch: char;
  BackColor: integer;
  GraphDriver, GraphMode: integer;
  MaxColors: word;
  AccX, VelX, CurX: array[1..4] of Double;
  AccY, VelY, CurY: array[1..4] of Double;
  Strength: array[1..8] of Double;
  InLen: array[1..8] of Double;
  LenX, LenY: Double;
  i: Integer;
  CurPage: Integer;
  BoxXmax, BoxYmax, BoxXmin, BoxYmin: Double;

{if (Gd = HercMono) or (Gd = EGA) or (Gd = EGA64) or (Gd = VGA) then}

procedure ChangePage;
begin
  if CurPage = 0 then
    begin
        CurPage := 1;
        SetActivePage(1);    {Устанавливает активную графическую страницу}
        SetVisualPage(0);    {Устанавливает номер видимой граф. страницы}
    end
  else
    begin
        CurPage := 0;
        SetActivePage(0);      {----//-----}
        SetVisualPage(1);      {----//-----}
    end;
end;

procedure DrawPoints(color:word);
var
   i: Integer;
begin

  ChangePage;

  Graph.ClearViewPort;
  SetBKColor(3);
  SetFillStyle(1,4);
  SetLineStyle(0,1,3);

  SetColor(8);
  Graph.Line(Round(BoxXmin), Round(BoxYmin), Round(CurX[1]), Round(CurY[1]));
  Graph.Line(Round(BoxXmax), Round(BoxYmin), Round(CurX[2]), Round(CurY[2]));
  Graph.Line(Round(BoxXmax), Round(BoxYmax), Round(CurX[3]), Round(CurY[3]));
  Graph.Line(Round(BoxXmin), Round(BoxYmax), Round(CurX[4]), Round(CurY[4]));
  Graph.Line(Round(CurX[1]), Round(CurY[1]), Round(CurX[2]), Round(CurY[2]));
  Graph.Line(Round(CurX[2]), Round(CurY[2]), Round(CurX[3]), Round(CurY[3]));
  Graph.Line(Round(CurX[3]), Round(CurY[3]), Round(CurX[4]), Round(CurY[4]));
  Graph.Line(Round(CurX[4]), Round(CurY[4]), Round(CurX[1]), Round(CurY[1]));

  SetColor(4);       { №5-фиолетовый цвет}
  for i:=1 to 4 do
  begin
    Graph.FillEllipse(Round(CurX[i]),Round(CurY[i]),6,6);
  end;
  SetColor(1);      { №6-коричневыйт цвет}
  Graph.Rectangle(Round(BoxXmin), Round(BoxYmin), Round(BoxXmax), Round(BoxYmax));
  SetLineStyle(UserBitLn, $FFFF, $FF);
end;


function DistFromTo(xf, yf, xt, yt: Double): Double;
var res: Double;
begin
     res := Sqrt((xf-xt)*(xf-xt)+(yf-yt)*(yf-yt));
     if res = 0 then DistFromTo := 1
     else DistFromTo := res;
end;

procedure SetIniLength;
begin            {вычисление длины пружины}
  InLen[1] := DistFromTo(BoxXmin, BoxYmin, CurX[1], CurY[1]);
  InLen[2] := DistFromTo(CurX[1], CurY[1], CurX[2], CurY[2]);
  InLen[3] := DistFromTo(BoxXmax, BoxYmin, CurX[2], CurY[2]);
  InLen[4] := DistFromTo(CurX[2], CurY[2], CurX[3], CurY[3]);
  InLen[5] := DistFromTo(BoxXmax, BoxYmax, CurX[3], CurY[3]);
  InLen[6] := DistFromTo(CurX[3], CurY[3], CurX[4], CurY[4]);
  InLen[7] := DistFromTo(BoxXmin, BoxYmax, CurX[4], CurY[4]);
  InLen[8] := DistFromTo(CurX[4], CurY[4], CurX[1], CurY[1]);
end;
{вычисление действующей силы,на шарики:общей силы и сил по данным ортам}
function GetForce(xf,yf,xt,yt:Double;n:Integer):Double;
begin
   GetForce:=(InLen[n]-DistFromTo(xf,yf,xt,yt))*Strength[n];
end;

function GetForceX(xf,yf,xt,yt:Double;n:Integer):Double;
begin
   GetForceX:=GetForce(xf,yf,xt,yt,n)*(xf-xt)/DistFromTo(xf,yf,xt,yt);
end;

function GetForceY(xf,yf,xt,yt:Double;n:Integer):Double;
begin
   GetForceY:=GetForce(xf,yf,xt,yt,n)*(yf-yt)/DistFromTo(xf,yf,xt,yt);
end;
  {главный цикл}
procedure MainCycle(dt: Double);
begin
     for i:=1 to 4 do
     begin
          AccX[i] := 0;    {начальные ускорения равны нулю}
          AccY[i] := 0;
     end;

     AccX[1] := AccX[1] + GetForceX(CurX[1], CurY[1], BoxXmin, BoxYmin, 1);
     AccX[1] := AccX[1] + GetForceX(CurX[1], CurY[1], CurX[2], CurY[2], 2);
     AccX[1] := AccX[1] + GetForceX(CurX[1], CurY[1], CurX[4], CurY[4], 8);
     AccY[1] := AccY[1] + GetForceY(CurX[1], CurY[1], BoxXmin, BoxYmin, 1);
     AccY[1] := AccY[1] + GetForceY(CurX[1], CurY[1], CurX[2], CurY[2], 2);
     AccY[1] := AccY[1] + GetForceY(CurX[1], CurY[1], CurX[4], CurY[4], 8);

     AccX[2] := AccX[2] + GetForceX(CurX[2], CurY[2], BoxXmax, BoxYmin, 3);
     AccX[2] := AccX[2] + GetForceX(CurX[2], CurY[2], CurX[1], CurY[1], 2);
     AccX[2] := AccX[2] + GetForceX(CurX[2], CurY[2], CurX[3], CurY[3], 4);
     AccY[2] := AccY[2] + GetForceY(CurX[2], CurY[2], BoxXmax, BoxYmin, 3);
     AccY[2] := AccY[2] + GetForceY(CurX[2], CurY[2], CurX[1], CurY[1], 2);
     AccY[2] := AccY[2] + GetForceY(CurX[2], CurY[2], CurX[3], CurY[3], 4);

     AccX[3] := AccX[3] + GetForceX(CurX[3], CurY[3], BoxXmax, BoxYmax, 5);
     AccX[3] := AccX[3] + GetForceX(CurX[3], CurY[3], CurX[2], CurY[2], 4);
     AccX[3] := AccX[3] + GetForceX(CurX[3], CurY[3], CurX[4], CurY[4], 6);
     AccY[3] := AccY[3] + GetForceY(CurX[3], CurY[3], BoxXmax, BoxYmax, 5);
     AccY[3] := AccY[3] + GetForceY(CurX[3], CurY[3], CurX[2], CurY[2], 4);
     AccY[3] := AccY[3] + GetForceY(CurX[3], CurY[3], CurX[4], CurY[4], 6);

     AccX[4] := AccX[4] + GetForceX(CurX[4], CurY[4], BoxXmin, BoxYmax, 7);
     AccX[4] := AccX[4] + GetForceX(CurX[4], CurY[4], CurX[3], CurY[3], 6);
     AccX[4] := AccX[4] + GetForceX(CurX[4], CurY[4], CurX[1], CurY[1], 8);
     AccY[4] := AccY[4] + GetForceY(CurX[4], CurY[4], BoxXmin, BoxYmax, 7);
     AccY[4] := AccY[4] + GetForceY(CurX[4], CurY[4], CurX[3], CurY[3], 6);
     AccY[4] := AccY[4] + GetForceY(CurX[4], CurY[4], CurX[1], CurY[1], 8);

     for i:=1 to 4 do         {вычисление скорстей и прирощений}
     begin                    {используется метод Эйлера}
          VelX[i] := VelX[i] + AccX[i] * dt;
          VelY[i] := VelY[i] + AccY[i] * dt;
          CurX[i] := CurX[i] + VelX[i] * dt;
          CurY[i] := CurY[i] + VelY[i] * dt;
     end;
     DrawPoints(13);                   {--------???--------}
end;

procedure Frame;
begin    {устанавливает визуальный порт (окно) для ввода вывода}
  SetViewPort(0, 0, Xmax, Ymax-(TextHeight(&#x27;M&#x27;)+4)-1,ClipOn);
  SetColor(MaxColors);
  Rectangle(0, 0, Xmax-1, (Ymax-(TextHeight(&#x27;M&#x27;)+4)-1)-1);
  SetViewPort(1, 1, Xmax-2, (Ymax-(TextHeight(&#x27;M&#x27;)+4)-1)-2,ClipOn);
end  { Frame };

procedure FullPort;
{ Set the view port to the entire screen }
begin
  SetViewPort(0, 0, Xmax, Ymax, ClipOn);
end; { FullPort }

procedure MessageFrame(Msg:string);
begin
  ChangePage;
  FullPort;
  SetColor(MaxColors);
  SetTextStyle(DefaultFont, HorizDir, 1);  {устанавливает стиль текста}
  SetTextJustify(CenterText, TopText);     {тип привязки текста к точке}
  SetLineStyle(SolidLn, 0, NormWidth);     {уст-т стиль линии}
  SetFillStyle(EmptyFill, 0); {уст один из стан-х шаблонов и цвет закраски}
  Bar(0, Ymax-(TextHeight(&#x27;M&#x27;)+4), Xmax, Ymax); {Bar-полоса}
  Rectangle(0, Ymax-(TextHeight(&#x27;M&#x27;)+4), Xmax, Ymax);
  OutTextXY(Xmax div 2, Ymax-(TextHeight(&#x27;M&#x27;)+2), Msg);
  { Go back to the main window }
  Frame;
  ChangePage;
  FullPort;
  SetColor(MaxColors);
  SetTextStyle(DefaultFont, HorizDir, 1);
  SetTextJustify(CenterText, TopText);
  SetLineStyle(SolidLn, 0, NormWidth);
  SetFillStyle(EmptyFill, 0);
  Bar(0, Ymax-(TextHeight(&#x27;M&#x27;)+4), Xmax, Ymax);
  Rectangle(0, Ymax-(TextHeight(&#x27;M&#x27;)+4), Xmax, Ymax);
  OutTextXY(Xmax div 2, Ymax-(TextHeight(&#x27;M&#x27;)+2), Msg);
  { Go back to the main window }
  Frame;
end  { MessageFrame };

procedure WaitToGo;   {процедура производящая остановку программы}
var
  Ch : char;
begin
  MessageFrame(&#x27;Press any key to continue... Esc aborts&#x27;);
  repeat until KeyPressed;
  Ch:=ReadKey;
  if Ch=#27 then begin     {#27-Esc}
      CloseGraph;
      Writeln(&#x27;All done.&#x27;);
      Halt(1);
    end
  else
    ClearViewPort;
  MessageFrame(&#x27;Press a key to stop motion, Esc quits.&#x27;);
end; { WaitToGo }
        {проверка на ощибки}
procedure TestGraphError(GraphErr: integer);
begin
  if GraphErr &lt;&gt; grOk then begin
    Writeln(&#x27;Graphics error: &#x27;, GraphErrorMsg(GraphErr));
    repeat until keypressed;
    ch:=readkey;
    Halt(1);
  end;
end;

procedure Init;
var
  Err, I: integer;
  StartX, StartY: integer;
  Resolution: ResolutionPreference;
  s: string;
begin
  Resolution:=Lower;
  if paramcount&gt;0 then begin
    s:=paramstr(1);
    if s[1]=&#x27;/&#x27; then
      if upcase(s[2])=&#x27;H&#x27; then
        Resolution:=Higher;
  end;

{  Ch := &#x27; &#x27;;
  GraphDriver := Detect;
  DetectGraph(GraphDriver, GraphMode);
  TestGraphError(GraphResult);
  case GraphDriver of
    CGA        : begin
                   GraphDriver := CGA;
                   GraphMode := CGAC1;
                 end;

    MCGA       : begin
                   case GraphMode of
                     MCGAMed, MCGAHi: GraphMode := MCGAC1;
                   end;
                 end;

    EGA         : begin
                    If Resolution = Lower then
                      GraphMode := EGALo
                    else
                      GraphMode := EGAHi;
                  end;

    EGA64       : begin
                    If Resolution = Lower then
                      GraphMode := EGA64Lo
                    else
                      GraphMode := EGA64Hi;
                  end;

     PC3270     : begin
                   GraphDriver := CGA;
                   GraphMode := CGAC1;
                 end;


     ATT400     : case GraphMode of
                    ATT400C1,
                    ATT400C2,
                    ATT400Med,
                    ATT400Hi  :
                      begin
                        GraphMode := ATT400C1;
                      end;
                  end;

  end;  }
  InitGraph(GraphDriver, GraphMode, &#x27;&#x27;);
  TestGraphError(GraphResult);
  SetGraphMode(1);
  SetTextStyle(DefaultFont, HorizDir, 1);
  SetTextJustify(CenterText, TopText);

  MaxColors:=GetMaxColor;
  BackColor:=0;
  Xmax:=GetMaxX;
  Ymax:=GetMaxY;
  ViewXmax:=Xmax-2;
  ViewYmax:=(Ymax-(TextHeight(&#x27;M&#x27;)+4)-1)-2;
end; {init}

procedure CheckForUserInput;
begin
  if KeyPressed then begin
    Ch := ReadKey;
    if Ch &lt;&gt; #27 then WaitToGo;
  end;
end;

function IntToStr(I: Real): String;
var
  S: string[16];
begin
  Str(I, S);
  IntToStr:=S;
end;

procedure DoMagic;
var i : Integer;
begin
     BoxXmin:=ViewXmax/4*1;
     BoxXmax:=ViewXmax/4*3;
     BoxYmin:=ViewYmax/4*1;
     BoxYmax:=ViewYmax/4*3;

     CurX[1]:=ViewXmax/3*1;
     CurY[1]:=ViewYmax/3*1;
     CurX[2]:=ViewXmax/3*2;
     CurY[2]:=ViewYmax/3*1;
     CurX[3]:=ViewXmax/3*2;
     CurY[3]:=ViewYmax/3*2;
     CurX[4]:=ViewXmax/3*1;
     CurY[4]:=ViewYmax/3*2;


     SetIniLength;

     for i:=1 to 8 do Strength[i]:=1+i;

     CurX[1]:=CurX[1]+10;
     CurY[1]:=CurY[1]-10;

  repeat
    MainCycle(0.1);
{    MessageFrame(IntToStr(AccX[1]));}
    CheckForUserInput;
  until Ch=#27;
end;

begin
   Init;
   Frame;
   MessageFrame(&#x27;Press a key to stop action, Esc quits.&#x27;);
   DoMagic;
   CloseGraph;
   RestoreCrtMode;
   Writeln(&#x27;The End.&#x27;);
end.



</code></pre>
        </div>
    </div>
</body>
</html>