<!DOCTYPE html>
<html lang="en" class="light">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gas Particle Simulation - Turbo Pascal Programs</title>
<meta name="description" content="Gas Particle Simulation - Turbo Pascal program by Kirill Arkhipenko (kusaku, retrewert, aks1983).">
<meta name="keywords" content="Kirill Arkhipenko, Кирилл Архипенко, kusaku, retrewert, aks1983, legacy">
<meta name="author" content="Kirill Arkhipenko">
<link rel="canonical" href="https://kusaku.su/legacy/turbopascal/gas/gas-particle-simulation.html">
<link rel="alternate" hreflang="en" href="https://kusaku.su/legacy/turbopascal/gas/gas-particle-simulation.html">
<link rel="alternate" hreflang="ru" href="https://kusaku.su/legacy/turbopascal/gas/gas-particle-simulation.html">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Gas Particle Simulation - Turbo Pascal Programs">
<meta property="og:description" content="Gas Particle Simulation - Turbo Pascal program by Kirill Arkhipenko (kusaku, retrewert, aks1983).">
<meta property="og:url" content="https://kusaku.su/legacy/turbopascal/gas/gas-particle-simulation.html">
<meta property="og:type" content="website">
<meta property="og:site_name" content="kusaku.su">
<meta property="og:image" content="https://kusaku.su/avatar.webp">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gas Particle Simulation - Turbo Pascal Programs">
<meta name="twitter:description" content="Gas Particle Simulation - Turbo Pascal program by Kirill Arkhipenko (kusaku, retrewert, aks1983).">
<meta name="twitter:image" content="https://kusaku.su/avatar.webp">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<style>
        html.light body { background: #ffffff; color: #24292f; }
        html.dark body { background: #0d1117; color: #c9d1d9; }
        html.light .bg-white { background-color: #ffffff; }
        html.dark .bg-white { background-color: #161b22; }
        html.light .text-gray-600 { color: #57606a; }
        html.dark .text-gray-600 { color: #8b949e; }
        html.light .text-gray-700 { color: #24292f; }
        html.dark .text-gray-700 { color: #c9d1d9; }
        html.light .text-gray-900 { color: #24292f; }
        html.dark .text-gray-900 { color: #c9d1d9; }
        html.light .border-gray-200 { border-color: #d0d7de; }
        html.dark .border-gray-200 { border-color: #30363d; }
        html.light .hover\:bg-gray-50:hover { background-color: #f6f8fa; }
        html.dark .hover\:bg-gray-50:hover { background-color: #21262d; }

        /* Link hover effects */
        html.light a:hover { color: #0969da; }
        html.dark a:hover { color: #1f6feb; }
        html.dark pre { background: #161b22 !important; }
        html.dark pre code { color: #c9d1d9; background: transparent !important; }
        html.dark .hljs { background: #161b22 !important; color: #c9d1d9; }
        html.dark .hljs-keyword { color: #ff7b72; }
        html.dark .hljs-string { color: #a5d6ff; }
        html.dark .hljs-number { color: #79c0ff; }
        html.dark .hljs-comment { color: #8b949e; }
        html.dark .hljs-function { color: #d2a8ff; }
        html.dark .hljs-variable { color: #ffa657; }
    </style>
<script>
        const getSystemPreference = () => window.matchMedia('(prefers-color-scheme: dark)').matches;
        const applyTheme = () => {
            const theme = localStorage.theme ?? 'system';
            const isDark = theme === 'system' ? getSystemPreference() : theme === 'dark';
            document.documentElement.classList.toggle('light', !isDark);
            document.documentElement.classList.toggle('dark', isDark);
        };
        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', applyTheme) : applyTheme();
        hljs.highlightAll();
    </script>    <script>
        // Register Pascal language for highlight.js
        hljs.registerLanguage('pascal', function(hljs) {
            return {
                keywords: {
                    keyword: 'and array begin case const div do downto else end file for function goto if in label mod nil not of or packed procedure program record repeat set then to type until var while with',
                    built_in: 'boolean char integer real text string',
                    literal: 'true false'
                },
                contains: [
                    hljs.C_LINE_COMMENT_MODE,
                    hljs.C_BLOCK_COMMENT_MODE,
                    hljs.APOS_STRING_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.C_NUMBER_MODE
                ]
            };
        });
    </script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-J8N1Q1GVVB"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-J8N1Q1GVVB');
</script>
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105986243', 'ym');
    ym(105986243, 'init', {ssr:true, webvisor:true, clickmap:true, accurateTrackBounce:true, trackLinks:true});
</script>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto">
        <nav class="mb-6">
            <a href="/legacy/turbopascal/turbopascal.html" class="inline-flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Back to Turbo Pascal Projects
            </a>
        </nav>
        <h1 class="text-3xl font-bold text-gray-900 mb-4">Gas Particle Simulation</h1>
        <p class="text-gray-600 mb-6">A particle physics simulation program that models ideal gas behavior. Uses object-oriented programming to simulate particles with velocity, acceleration, and forces. Features graphical visualization using BGI graphics, particle interactions, statistical analysis, and real-time rendering.</p>
        <div class="bg-white border border-gray-200 rounded-xl p-6 mb-6">
            <h2 class="font-semibold text-gray-900 mb-4">Source Code:</h2>
            <pre><code class="language-pascal">﻿program Gas;

uses
  Crt, Graph;

const
{Константы - шаг времени,  максимальное число частиц и измерений}
   dt      =   5e-3;
   maxCount=   1000;
   maxStat =    100;

type
{Тип данных - вектор и указатель на вектор (т.к. функции возвращают только простые типы)}
  pTVector = ^TVector;
  TVector = record
    x,y : Double;
  end;
{Объект - частица}
  pTParticleObj = ^TParticleObj;
  TParticleObj = object
    acc,
    vel,
    cur : TVector;
    radius,
    sforce : Double;
    underF : Boolean;
    isFree : Boolean;
    number : Integer;
    constructor Init(_cur, _vel: TVector; _radius, _sforce: Double; _number : Integer);
    procedure IntegrateFirst(dt: Double);
    procedure IntegrateSecond(dt: Double);
    procedure Draw;virtual;
    destructor Done;
    private
    function DistTo(That: pTParticleObj): Double;
    function GetForce(That: pTParticleObj): pTVector;
  end;

{Объект - частица}
  pTPartWlkmObj = ^TPartWlkmObj;
  TPartWlkmObj = object(TParticleObj)
    ch : Char;
    constructor Init(_cur, _vel: TVector; _radius, _sforce: Double; _number : Integer; _ch: Char);
    procedure Draw;virtual;
  end;

{Тип данных - запись, информация о контейнере}
  TContainer = record
    part : array[1..maxCount] of pTParticleObj;
    firstcount, count: Integer;
    radius: Integer;
    sforce: Integer;
    minX, minY, maxX, maxY : Double;
    minVel, maxVel: Integer;
    enableGraph: Boolean;
    needDispose: Boolean;
    skipFrames: Integer;
  end;
{Тип данных - запись, информация о статистике}
  TStatistic = record
    statData : array[1..maxStat] of Integer;
    fromStat, toStat : Integer;
    curStat: Integer;
    statCount: Integer;
    statGaps: Integer;
  end;

var
  Xmax,
  Ymax,
  ViewXmax,
  ViewYmax : Integer;
  TextHi, TextWi : Integer;
  GraphDriver, GraphMode : Integer;
  CurPage : Integer;
  EnableStat, StatChanged : Boolean;
  container: TContainer;
  statistic: TStatistic;
  zero: TVector;

{Конструктор объекта - частицы}
constructor TParticleObj.Init(_cur, _vel: TVector; _radius, _sforce: Double; _number : Integer);
begin
     cur := _cur;
     vel := _vel;
     radius := _radius;
     sforce := _sforce;
     number := _number;
end;
{метод - расстояние до другой частицы}
function TParticleObj.DistTo(That : pTParticleObj): Double;
var res: Double;
begin
     with That^.cur do
     res := Sqrt((cur.x - x) * (cur.x - x) + (cur.y - y) * (cur.y - y));
     if res = 0 then DistTo := 1
     else DistTo := res;
end;
{метод, возвращающий указатель на вектор силы}
function TParticleObj.GetForce(That : pTParticleObj): pTVector;
var resS: Double;
    resV: TVector;
    presV: pTVector;
    dist: Double;
begin
   dist := DistTo(That);
   resS := (That^.radius + radius) - dist;
   if resS &gt; 0 then resS := resS * sforce
   else resS := 0;
   with That^.cur do
   begin
       resV.x := (cur.x - x) / dist * resS;
       resV.y := (cur.y - y) / dist * resS;
   end;

   GetForce := @resV;
end;
{Интегрирование уравнения движения: вычисление сила действующий на частицу, скорости}
procedure TParticleObj.IntegrateFirst(dt: Double);
var i: Integer;
    force: TVector;
    curWall: TVector;
    wall: pTParticleObj;
begin
     acc.x := 0;
     acc.y := 0;

     curWall.x := container.minX;
     curWall.y := cur.y;
     New(wall, Init(curWall, zero, 0, 0, 0));
     force := GetForce(wall)^;
     Dispose(wall);
     acc.x := acc.x + force.x;
     acc.y := acc.y + force.y;

     curWall.x := container.maxX;
     curWall.y := cur.y;
     New(wall, Init(curWall, zero, 0, 0, 0));
     force := GetForce(wall)^;
     Dispose(wall);
     acc.x := acc.x + force.x;
     acc.y := acc.y + force.y;

     curWall.x := cur.x;
     curWall.y := container.minY;
     New(wall, Init(curWall, zero, 0, 0, 0));
     force := GetForce(wall)^;
     Dispose(wall);
     acc.x := acc.x + force.x;
     acc.y := acc.y + force.y;

     curWall.x := cur.x;
     curWall.y := container.maxY;
     New(wall, Init(curWall, zero, 0, 0, 0));
     force := GetForce(wall)^;
     Dispose(wall);
     acc.x := acc.x + force.x;
     acc.y := acc.y + force.y;

     for i:=1 to container.count do
         if i&lt;&gt;number then
              begin
                   force := GetForce(container.part[i])^;
                   acc.x := acc.x + force.x;
                   acc.y := acc.y + force.y;
              end;

     if (acc.x &lt;&gt; 0) or (acc.y &lt;&gt; 0) then
        underF := True
     else underF := False;

     EnableStat := EnableStat and not underF; {если на частицу не действуют силы, то можно измерять скорость}

     vel.x := vel.x + acc.x * dt;
     vel.y := vel.y + acc.y * dt;
end;
{Интегрирование уравнения движения: вычисление новой координаты}
procedure TParticleObj.IntegrateSecond(dt: Double);
begin
     cur.x := cur.x + vel.x * dt;
     cur.y := cur.y + vel.y * dt;
     with container, cur do
     isFree := (x &gt; maxX) or (x &lt; minX) or (y &gt; maxY) or (y &lt; minY);
end;
{рисуем частицу}
procedure TParticleObj.Draw;
begin
    if underF then
       begin
           SetColor(4); {красным, если на нее действует сила}
           SetFillStyle(SolidFill, 4);
           FillEllipse(Trunc(cur.x), Trunc(cur.y), Trunc(radius), Trunc(radius));
       end
    else
       begin
           SetColor(9); {иначе - синим}
           SetFillStyle(SolidFill, 9);
           FillEllipse(Trunc(cur.x), Trunc(cur.y), Trunc(radius), Trunc(radius));
       end;
end;
{не нужен}
destructor TParticleObj.Done;
begin
end;

constructor TPartWlkmObj.Init(_cur, _vel: TVector; _radius, _sforce: Double; _number : Integer; _ch: Char);
begin
     TParticleObj.Init(_cur, _vel, _radius, _sforce, _number);
     ch := _ch;
end;

procedure TPartWlkmObj.Draw;
begin
     SetColor(12);
     SetFillStyle(SolidFill, 4);
     OutTextXY(Trunc(cur.x - TextWi/2), Trunc(cur.y - TextHi/2), ch);
end;

{из целого в строку}
function IntToStr(I: Real): String;
var
  S: string[16];
begin
  Str(I:8:0, S);
  IntToStr := S;
end;
{меняем страницу}
procedure ChangePage;
begin
  if CurPage = 0 then
    begin
        CurPage := 1;
        SetActivePage(1);
        SetVisualPage(0);
    end
  else
    begin
        CurPage := 0;
        SetActivePage(0);
        SetVisualPage(1);
    end;
end;
{рисование на всем доступном экране}
procedure FullPort;
begin

end;
{рама}
procedure DrawFrame;
var i: integer;
begin
  ChangePage;
  SetViewPort(0, 0, Xmax, Ymax, ClipOn);
  SetFillStyle(SolidFill, 0);
  Bar(0, 0, Xmax, Ymax);
  SetColor(7);
  SetFillStyle(SolidFill, 1);
  Bar(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
  Rectangle(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
  SetFillStyle(SolidFill, 8);
  Bar(0, Ymax - (TextHi + 4), Xmax, Ymax);
  Rectangle(0, Ymax - (TextHi + 4), Xmax, Ymax);
  ChangePage;
  SetViewPort(0, 0, Xmax, Ymax, ClipOn);
  SetFillStyle(SolidFill, 0);
  Bar(0, 0, Xmax, Ymax);
  SetColor(7);
  SetFillStyle(SolidFill, 1);
  Bar(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
  Rectangle(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
  SetFillStyle(SolidFill, 8);
  Bar(0, Ymax - (TextHi + 4), Xmax, Ymax);
  Rectangle(0, Ymax - (TextHi + 4), Xmax, Ymax);
  {draw on top field only}
  SetViewPort(1, 1, Xmax - 1, Ymax - (TextHi + 4) - 3, ClipOn);
end;
{строка состояния}
procedure MessageFrame(Msg:string);
begin
  ChangePage;
  SetViewPort(1, Ymax - (TextHi + 4) + 1, Xmax - 1, Ymax - 1, ClipOn);
  SetFillStyle(SolidFill, 8);
  Bar(1, 1, Xmax - 1, TextHi + 2);
  SetColor(15);
  SetTextStyle(DefaultFont, HorizDir, 1);
  SetTextJustify(CenterText, TopText);
  OutTextXY(Xmax div 2, 2, Msg);
  ChangePage;
  SetViewPort(1, Ymax - (TextHi + 4) + 1, Xmax - 1, Ymax - 1, ClipOn);
  SetFillStyle(SolidFill, 8);
  Bar(1, 1, Xmax - 1, TextHi + 2);
  SetColor(15);
  SetTextStyle(DefaultFont, HorizDir, 1);
  SetTextJustify(CenterText, TopText);
  OutTextXY(Xmax div 2, 2, Msg);
  {draw on top field only}
  SetViewPort(1, 1, Xmax - 1, Ymax - (TextHi + 4) - 3, ClipOn);
end;
{добавляем измерение}
procedure AddMeasure;
var i,k: Integer;
    cvel: Double;
    gapW: Double;
begin
     if (statistic.curStat &gt;= statistic.fromStat) and
     (statistic.curStat &lt;= statistic.toStat) then
     begin
     gapW := 3 * container.maxVel / statistic.statGaps; {промежуток скоростей}
     with statistic do
     for i:=1 to statGaps do
          for k:=1 to container.count do
            with container.part[k]^ do
               begin
                    if isFree then continue;
                    cvel := Sqrt(vel.x * vel.x + vel.y * vel.y);
                    if (cvel &gt; gapW * (i - 1)) and (cvel &lt; gapW * i) then
                    Inc(statData[i]);
               end;
     end;
     Inc(statistic.curStat);
     MessageFrame(Concat(&#x27;Current measure #&#x27;, IntToStr(statistic.curStat)));
end;
{рисуем гистограмму}
procedure DrawStatPlot;
var i, maxStat: Integer;
    gapW      : Double;
begin
    with statistic, container do
    begin
         gapW := 3 * maxVel / statGaps;

         maxStat := 0;

         for i:=1 to statGaps do
             if maxStat &lt; statData[i] then maxStat := statData[i];

         ChangePage;
         SetFillStyle(SolidFill, 1);
         Bar(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
         SetColor(9);
         Graph.Rectangle(Trunc(minX), Trunc(minY), Trunc(maxX), Trunc(maxY));
         SetColor(11);
         for i:=1 to statGaps do
             begin
                  Graph.Rectangle(
                  Trunc(minX + (maxX - minX) / statGaps * (i - 1)),
                  Trunc(maxY),
                  Trunc(minX + (maxX - minX) / statGaps * i ),
                  Trunc(maxY - (maxY - minY) / maxStat * statData[i]));
                  OutTextXY(
                  Trunc(minX + (maxX - minX) / statGaps * (i - 1)),
                  Trunc(maxY + (i mod 3) * TextHi + 3),
                  IntToStr(GapW*i));
              end;
         for i:=1 to Trunc((maxY-minY)/(TextHi+3)) do
                  OutTextXY(
                  Trunc(minX - 4*(TextWi + 2)),
                  Trunc(maxY - (TextHi+3)*i),
                  IntToStr(Trunc(maxStat/(maxY-minY)*(TextHi+3)*i)));
         ChangePage;
    end;
end;
{рисуем молекулы}
procedure DrawPoints;
var
   i : Integer;
begin
  SetFillStyle(SolidFill, 1);
  Bar(0, 0, Xmax, Ymax - (TextHi + 4) - 2);
  SetColor(9);
  with container do
  Graph.Rectangle(Trunc(minX), Trunc(minY), Trunc(maxX), Trunc(maxY));
  for i:=1 to container.count do
      container.part[i]^.Draw;
  ChangePage;
end;

{procedure WaitOrExit(Msg: String);forward;}

procedure Remove(That : pTParticleObj);
var i: 	 Integer;
begin
     MessageFrame(&#x27;Particle #&#x27; + IntToStr(That^.number) + &#x27; has gone far...&#x27;);
     Dec(container.count);
     for i:= That^.number to container.count do
     	 begin
         	container.part[i] := container.part[i + 1];
			container.part[i]^.number := i;
         end
     container.part[container.firstcount] := That;
{     Dispose(That);}
end;


{цикл метода Эйлера, также проверяет, можно ли производить измерение}
procedure MainCycle(dt: Double);
var i,k : Integer;
begin
     EnableStat := True;
     for i:=1 to container.count do
     begin
          container.part[i]^.IntegrateFirst(dt);
     end;
     for i:=1 to container.count do
     begin
          container.part[i]^.IntegrateSecond(dt);
     end;

     for i:=1 to container.count do
     begin
          if container.part[i]^.isFree then Remove(container.part[i]);
     end;

     StatChanged := StatChanged or not EnableStat;
     if EnableStat and StatChanged then
        begin
         AddMeasure;
         StatChanged := False;
        end;
end;
{ввод целого параметра}
procedure InputParam(var param: Integer; Msg: String);
var Ch : Char;
    Done: Boolean;
    StrVal: String;
    i: Integer;
begin
    Done := False;
    Str(param, StrVal);
       repeat
           MessageFrame(Concat(Msg, &#x27; : &#x27;, StrVal));
           Ch:=ReadKey;
           case Ch of
               #13: Done:=True;
               &#x27;0&#x27;..&#x27;9&#x27; : StrVal := Concat(StrVal, Ch);{только цифры}
               #8: Delete(StrVal, Length(StrVal), 1);{enter - конец ввода}
           else
               MessageFrame(&#x27;Must be a numeric value!&#x27;);
               repeat until KeyPressed;
               ReadKey;
           end;
       until Done;
    Val(StrVal, param, i);
end;
{ввод логического параметра}
procedure InputParamB(var param: Boolean; Msg: String);
var Ch : Char;
    Done: Boolean;
    StrVal: String;
    i: Integer;
begin
    Done := False;
    if param then StrVal := &#x27;Y&#x27;
    else StrVal := &#x27;N&#x27;;
       repeat
           MessageFrame(Concat(Msg, &#x27; [Y/N]: &#x27;, StrVal));
           Ch:=ReadKey;
           case Ch of
               #13: Done:=True;
               &#x27;y&#x27;,&#x27;Y&#x27;,&#x27;n&#x27;,&#x27;N&#x27; : StrVal := Ch;
               #8: Delete(StrVal, Length(StrVal), 1);
           else
               MessageFrame(&#x27;Must be &quot;y&quot; or &quot;n&quot;!&#x27;);
               repeat until KeyPressed;
               ReadKey;
           end;
       until Done and (Length(StrVal) = 1);
    param := (StrVal = &#x27;y&#x27;) or (StrVal = &#x27;Y&#x27;);
end;
{создает контейнер с частицами}
procedure MakeContainer;
var i: Integer;
    cur, vel: TVector;
    absVel, angle : Double;
begin
     if container.needDispose then
            for i:=1 to container.firstcount do
                    Dispose(container.part[i]);
     repeat
         InputParam(container.firstcount, &#x27;Input quantity of particles (1..1000)&#x27;);
         if (container.count &lt; 1) or (container.count &gt; MaxCount) then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not ((container.count &lt; 1) or (container.count &gt; MaxCount));
     container.count := container.firstcount;
     repeat
         InputParam(container.radius, &#x27;Input radius of particles (1..20)&#x27;);
         if (container.radius &lt; 1) or (container.radius &gt; 20) then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not ((container.radius &lt; 1) or (container.radius &gt; 20));
     repeat
         InputParam(container.sforce, &#x27;Input spring force of particles (0..100000)&#x27;);
         if (container.sforce &gt; 100000) then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not ((container.sforce &gt; 100000));
     repeat
         InputParam(container.minVel, &#x27;Input minimal velocity of particles&#x27;);
         InputParam(container.maxVel, &#x27;Input maximal velocity of particles&#x27;);
         if container.minVel &gt; container.minVel then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not (container.minVel &gt; container.maxVel);
     InputParamB(container.enableGraph, &#x27;Enable graphics&#x27;);
     if (container.enableGraph) then
     repeat
         InputParam(container.skipFrames, &#x27;Amount of skipped frames per calculation (0..50)&#x27;);
         if (container.skipFrames &lt; 0) or (container.skipFrames &gt; 50) then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not ((container.skipFrames &lt; 0) or (container.skipFrames &gt; 50));

    for i:=1 to container.count do
    begin
         cur.x := (container.maxX - container.minX) * Random + container.minX;
         cur.y := (container.maxY - container.minY) * Random + container.minY;
         absVel := container.minVel + (container.maxVel - container.minVel)*Random;
         angle := 2 * Pi * Random;
         vel.x := absVel * Cos(angle);
         vel.y := absVel * Sin(angle);
         New(container.part[i], Init(cur, vel, container.radius, container.sforce, i));
    end;
    container.needDispose := True;
end;
{создает статистику}
procedure MakeStatistic;
var i : Integer;
begin
     repeat
         InputParam(statistic.statCount, &#x27;Input amount of measurements (&lt;100)&#x27;);
         if statistic.statCount &gt; maxStat then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not (statistic.statCount &gt; maxStat);
     repeat
         InputParam(statistic.fromStat, &#x27;Input first measure of statistics&#x27;);
         InputParam(statistic.toStat, &#x27;Input last measure of statistics&#x27;);
         if (statistic.fromStat &gt; statistic.toStat) or
         (statistic.fromStat &gt; statistic.statCount) or
         (statistic.toStat &gt; statistic.statCount) then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not ((statistic.fromStat &gt; statistic.toStat) or
                (statistic.fromStat &gt; statistic.statCount) or
                (statistic.toStat &gt; statistic.statCount));
     repeat
         InputParam(statistic.statGaps, &#x27;Input number of columns on histogram (&lt;100)&#x27;);
         if statistic.statGaps &gt; 100 then
         begin
              MessageFrame(&#x27;Wrong input!&#x27;);
              repeat until KeyPressed;
              ReadKey;
         end;
     until not (statistic.statGaps &gt; 100);
     statistic.curStat:=0;
     for i:=1 to statistic.statCount do statistic.statData[i] := 0;
end;
{ожидает нажатия клавиши и выходит из программы}
procedure WaitOrExit(Msg: String);
var
  Ch      : char;
  WantExit: Boolean;
begin
  MessageFrame(Msg);
  repeat until KeyPressed;
  Ch := ReadKey;
  if Ch = #27 then
   begin
      InputParamB(WantExit, &#x27;Do you really want to exit?&#x27;);
      if WantExit then
      begin
          CloseGraph;
          RestoreCrtMode;
          Writeln(&#x27;Have a nice day!&#x27;);
      end;
   end;
end;
{проверяет ввод пользователя}
procedure CheckForUserInput;
var Ch: Char;
begin
  if KeyPressed then
  begin
    Ch := ReadKey;
    case Ch of
    &#x27;n&#x27;,&#x27;N&#x27;: begin
             MakeContainer;
             MakeStatistic;
             end;
    &#x27;s&#x27;,&#x27;S&#x27;: AddMeasure;
    else
        WaitOrExit(&#x27;Press any key to continue, Esc quits&#x27;);
    end;
  end;
end;

procedure Demo;
const
    WelcomeStr : Array[1..4] of String =
    (&#x27;WELCOME!!!&#x27;,
     &#x27; &#x27;,
     &#x27;This program illustrates&#x27;,
     &#x27;Maxwell distribution for Ideal Gases&#x27;
    );
var wpart: pTPartWlkmObj;
    cur, vel: TVector;
    i,k : Integer;
begin
     MessageFrame(&#x27;LOADING...&#x27;);
    begin
     container.firstcount := 49;
     container.count := 0;
     container.radius := 4;
     container.sforce := 10000;
     container.minVel := 75;
     container.maxVel := 300;
     container.minX := ViewXmax/6*1;
     container.minY := ViewYmax/6*1;
     container.maxX := ViewXmax/6*5;
     container.maxY := ViewYmax/6*5;
     container.needDispose := True;
     container.enableGraph := True;
     container.skipFrames := 0;
     statistic.fromStat:=0;
     statistic.toStat:=100;
     statistic.statGaps:=30;
     statistic.statCount:=100;
    end;
    with container do
    for i:=1 to 4 do
        for k:=1 to Length(WelcomeStr[i]) do
            begin
            if WelcomeStr[i,k] = &#x27; &#x27; then continue;
            cur.x := (maxX + minX - Length(WelcomeStr[i]) * (TextWi + 1)) /2 +  k * (TextWi + 1);
            cur.y := (maxY + minY - 8 * (TextHi + 2)) / 2 + i * (TextHi + 2);
            vel.x := 300 * (0.5 - Random);
            vel.y := 300 * (0.5 - Random);
            New(wpart, Init(cur, vel, 0, sforce, 0, WelcomeStr[i,k]));
            Inc(count);
            part[count] := wpart;
            end;
    with container do
    begin
     for i:=1 to 100 do MainCycle(dt);

     MessageFrame(&#x27;Displaying Demo!&#x27;);

     for i:=1 to 100 do
     begin
          if (i mod 4 = 0) then DrawPoints;
          MainCycle(-dt);
     end;
     DrawPoints;
     ChangePage;
     SetTextStyle(DefaultFont, HorizDir, 1);
     SetTextJustify(CenterText, TopText);
     SetColor(2);
     OutTextXY(
               Trunc((maxX + minX) / 2),
               Trunc((maxY + minY) / 2 + 3 * (TextHi + 2)),
               &#x27;Arkhipenko Kirill, group #212.&#x27;);
     SetColor(2);
     OutTextXY(
               Trunc((maxX + minX) / 2),
               Trunc((maxY + minY) / 2 + 4 * (TextHi + 2)),
               &#x27;Term paper.&#x27;);
     SetColor(10);
     OutTextXY(
               Trunc((maxX + minX) / 2),
               Trunc((maxY + minY) / 2 + 6 * (TextHi + 2)),
               &#x27;Visit http://www.physfac.nm.ru/ to get more!&#x27;);
     ChangePage;
     WaitOrExit(&#x27;Press Any key to continue or Esc to exit.&#x27;);
    end;
end;

{главная функция}
procedure DoMagic;
var i : Integer;
    counter: Integer;
begin
     MakeContainer;
     MakeStatistic;

     MessageFrame(&#x27;Press &quot;n&quot;, &quot;s&quot; or &quot;p&quot;, Esc quits, any other key pauses.&#x27;);

     counter := container.skipFrames;
     repeat
           MainCycle(dt);
           if container.enableGraph then
              if counter &gt; container.skipFrames then
                 begin
                      DrawPoints;
                      counter := 0;
                 end
              else
                  counter := counter + 1;
           CheckForUserInput;
     until statistic.curStat = statistic.statCount;
end;

procedure TestGraphError(GraphErr: integer);
begin
  if GraphErr &lt;&gt; grOk then begin
    Writeln(&#x27;Graphics error: &#x27;, GraphErrorMsg(GraphErr));
    repeat until KeyPressed;
    ReadKey;
    Halt(1);
  end;
end;
{инициализация графики}
procedure Init;
begin
  GraphDriver := Detect;
  DetectGraph(GraphDriver, GraphMode);
  TestGraphError(GraphResult);
  case GraphDriver of
    CGA        : begin
                   GraphDriver := CGA;
                   GraphMode := CGAC1;
                 end;

    MCGA       : begin
                   case GraphMode of
                     MCGAMed, MCGAHi: GraphMode := MCGAC1;
                   end;
                 end;

    EGA         : begin
                      GraphMode := EGAHi;
                  end;

    EGA64       : begin
                      GraphMode := EGA64Hi;
                  end;

     PC3270     : begin
                   GraphDriver := CGA;
                   GraphMode := CGAC1;
                 end;


     ATT400     : case GraphMode of
                    ATT400C1,
                    ATT400C2,
                    ATT400Med,
                    ATT400Hi  :
                      begin
                        GraphMode := ATT400C1;
                      end;
                  end;

  end;
  InitGraph(GraphDriver, GraphMode, &#x27;&#x27;);
  TestGraphError(GraphResult);
  SetGraphMode(1);
  SetTextStyle(DefaultFont, HorizDir, 1);
  SetTextJustify(CenterText, TopText);
  Xmax := GetMaxX;
  Ymax := GetMaxY;
  TextHi := TextHeight(&#x27;M&#x27;);
  TextWi := TextWidth(&#x27;M&#x27;);
  ViewXmax := Xmax - 2;
  ViewYmax := (Ymax - (TextHi + 4) - 1) - 2;
end;
{}
begin
   Init;
   DrawFrame;
   repeat
      Demo;
      DoMagic;
      DrawStatPlot;
      WaitOrExit(&#x27;Press any key to start again or Esc to exit.&#x27;);
   until False;
end.
</code></pre>
        </div>
    </div>
</body>
</html>